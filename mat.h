/*************************************************************//*                   Matrix library                          *//*                                                           *//*  History : 2008 Jan. 25                                   *//*                                                           *//*************************************************************///#define     MAT_MAIN_TEST#ifdef  MAT_MAIN_TEST#define _MAIN#endif#include <math.h>#include "gentool.h"#include <stdarg.h>/*------------------------------------------------------------*//*      Constant Definition                                   *//*------------------------------------------------------------*/#define     MAT_MIN_DOUBLE      (1.0E-15)#define     MAT_MAX_PRINT       10 /* max num for simaltaneous print *///#define     MAT_MAIN_TEST#define     MAT_PRI_CHK         /* if defined, do primary check */#ifdef _MAINint         MatErrStop = TRUE;#elseextern int  MatErrStop;#endif/*------------------------------------------------------------*//*      Struct definition                                     *//*------------------------------------------------------------*/typedef struct{    double      *dat;   /* ptr to data */    int          row;   /* row         */    int          col;   /* column      */    int          flg;   /* free flag. If FALSE, MatFree dosen't free *dat */    double       det;} MATRIX;/*------------------------------------------------------------*//*      Function Prototypes                                   *//*------------------------------------------------------------*/MATRIX      *MatGen(int col, int row);MATRIX      *MatDup(MATRIX *m);MATRIX      *MatGenUnit(int dim);MATRIX      *MatGenInit(int col, int row, double *dat);MATRIX      *MatGenTrans(MATRIX *m);MATRIX      *MatTrans(MATRIX *m);int          MatPut(MATRIX *m, int col, int raw, double val);void         MatFree(MATRIX *m);void         MatFreeN(int num, ...);MATRIX      *MatExtractRow(MATRIX *m, int row);MATRIX      *MatExtractRowPtr(MATRIX *m, int row);MATRIX      *MatExtractCol(MATRIX *m, int col);MATRIX      *MatGenAdd(MATRIX *m1, MATRIX *m2);MATRIX      *MatGenSub(MATRIX *m1, MATRIX *m2);MATRIX      *MatGenMul(MATRIX *m1, MATRIX *m2);MATRIX      *MatAdd(MATRIX *m1, MATRIX *m2);MATRIX      *MatSub(MATRIX *m1, MATRIX *m2);MATRIX      *MatMul(MATRIX *m1, MATRIX *m2);MATRIX      *MatGenInvGJ(MATRIX *m);MATRIX      *MatLsmGJ(int NumVal, int NumSample, MATRIX *X, MATRIX *Y);MATRIX      *MatPrint(MATRIX *m, const char *format);MATRIX      *MatPrintN(int num, const char *format, ... );void Suitei(void);/*------------------------------------------------------------*//*   Test main                                                *//*------------------------------------------------------------*/#ifdef MAT_MAIN_TESTint     main( void ){    int         i, j;    double      d1[] = {                1.0, 2.0, 3.0, 4.0, 5.0,                 6.0, 7.0, 8.0, 9.0, 10.0,                 11.0, 12.0, 13.0, 14.0, 15.0,                16.0, 17.0, 18.0, 19.0, 20.0,                21.0, 22.0, 23.0, 24.0, 25.0             };        double      dA[] = {1.0, 2.0, 0.0, 3.0};    double      dB[] = {1.0, 0.0, 2.0, 2.0, 1.0, 3.0};    double      di[] = {1.0, 1.0, -3.0, 2.0, 5.0, 1.0, 1.0, 3.0, 2.0};        MATRIX      *m, *m1, *m2, *m3, *m4, *v;    MATRIX      *A, *B, *C;                static double      datx[] =                {1.0, 0.3, 0.5, 0.3,                 3.0, 3.0, 6.0, 3.0,                4.0, 3.0, 6.0, 7.0,                1.0, 5.0, 7.0, 3.0,                7.0, 4.0, 2.0, 4.0,                7.0, 4.0, 6.0, 3.0,                6.0, 7.0, 4.0, 3.0,                5.0, 6.0, 3.0, 7.0,                8.0, 4.0, 3.0, 5.0,                7.0, 4.0, 7.0, 2.0,                8.0, 4.0, 3.0, 6.0,                5.0, 7.0, 3.0, 6.0,                8.0, 4.0, 7.0, 5.0 };        static double      daty[] =            {2.32, 17.1, 27.7, 17.0, 20.4, 21.6, 20.3, 27.5,            24.7, 22.5, 27.1, 25.6, 28.3};        m1 = MatGenInit(4, 13, datx);    m2 = MatGenInit(1, 13, daty);    m  = MatLsmGJ(4, 13, m1, m2);        MatPrint(m, "%f ");        exit(1);            m = MatGenUnit(5);     MatPut(m, 1, 3, 7.0);    MatPut(m, 2, 3, 4.0);    MatPrint(m, "%#4.3g ");        m1 = MatGenInit(5, 5, d1);    MatPrint(m1, "%#4.3g ");        m2 = MatGenTrans(m1);    MatPrint(m2, "%#4.3g ");        m3 = MatDup(m1);        MatSub(m3, m2);    MatPrint(m3, "% -#4.3g ");        MatFree(m3);        m3 = MatGenSub(m1, m2);    MatPrintN(3, "% -#4.3g ", m1, m2, m3);            //    MatPrintN(3, "%#4.3g ", v, m, v);    //    A = MatGenInit(3, 3, di);//    B = MatDup(A);        B = MatGenUnit(5);//    B = MatGenInit(3, 2, dB);        MatPrint(A, "% -#4.3g ");    MatPrint(B, "% -#4.3g ");        C = MatGenInvGJ(m1);    MatPrint(C, "% -#4.3g ");        MatPrint(m1, "% -#4.3g ");        m2 = MatGenUnit(5);    m3 = MatGenInvGJ(m2);//    MatPrint(m3, "% -#4.3g ");    MatPrint(m3, "% -#4.3g ");}#endif/*------------------------------------------------------------*//*  Marix generation (only allocate memory)                   *//*------------------------------------------------------------*/MATRIX      *MatGen(int col, int row){    MATRIX  *m;    int      i;    #ifdef MAT_PRI_CHK    if(row <= 0 || col <= 0){        fprintf(stderr, "Error in MatGen(). Wrong dimension "                "col = %d, row = %d\n", col, row);        exit(1);    }#endif        m = (MATRIX *)malloc(sizeof(MATRIX));        if(m == NULL){        if(MatErrStop != TRUE) return NULL;         else goto MatGenErr;    }    m->dat = (double *)malloc((size_t)col * (size_t)row * sizeof(double));        if(m->dat == NULL){        if(MatErrStop != TRUE) return NULL;        else goto MatGenErr;    }        for(i = 0; i < row * col; i++) m->dat[i] = 0.0;        m->row = row; m->col = col; m->flg = TRUE; m->det = 0.0;    return m;      MatGenErr:    fprintf(stderr,             "Error in MatGen(). Memory allocation was faild\n");    exit(1);            }/*------------------------------------------------------------*//*  Marix duplicate                                           *//*------------------------------------------------------------*/MATRIX      *MatDup(MATRIX *m){    MATRIX      *d;        d = MatGen(m->col, m->row);    if(d == NULL) return NULL;        d->det = m->det;    memcpy((void *)d->dat, (void *)m->dat,             (size_t)m->col * (size_t)m->row * sizeof(double));        return d;}/*------------------------------------------------------------*//*  Marix generation (*dat ptr point existing data series)    *//*------------------------------------------------------------*/MATRIX      *MatGenInit(int col, int row, double *dat){    MATRIX  *m;    int      i;    #ifdef MAT_PRI_CHK    if(row <= 0 || col <= 0){        fprintf(stderr, "Error in MatGenInit(). Wrong dimension "                "col = %d, row = %d\n", col, row);        exit(1);    }#endif        m = MatGen(col, row);    if(m == NULL) return NULL;        for(i = 0; i < m->col * m->row; i++) m->dat[i] = dat[i];        return m;}/*------------------------------------------------------------*//*  Unit marix generation                                     *//*------------------------------------------------------------*/MATRIX      *MatGenUnit(int dim){    MATRIX  *m;    double  *dp;    int      i, j;    #ifdef MAT_PRI_CHK    if(dim <= 0){        fprintf(stderr, "Error in MatGenUnit(). Wrong dimension. "                        "dim = %d\n", dim);        exit(1);    }#endif        m = MatGen(dim, dim);        if(m == NULL) return NULL;        dp = m->dat;    for(i = 0; i < dim; i++){        dp[i] = 1.0;        dp += dim;    }        return m;}/*------------------------------------------------------------*//*  Eliminate matrix                                          *//*------------------------------------------------------------*/void    MatFree(MATRIX *m){    if(m->flg == TRUE) free((void *)m->dat);    free((void *)m);}/*------------------------------------------------------------*//*  Value input to matrix                                     *//*------------------------------------------------------------*/int        MatPut(MATRIX *m, int col, int row, double val){    #ifdef MAT_PRI_CHK    if(row <= 0 || col <= 0 || row > m->row || col > m->col){            fprintf(stderr, "Error in MatPut(). Element out of range. "                            "col = %d, row = %d\n", col, row);        fprintf(stderr, "Given matrix dimension :  "                        "col = %d, row = %d\n", m->col, m->row);            exit(1);    }#endif        row--; col--;        m->dat[m->col * row + col] = val;    return TRUE;}/*------------------------------------------------------------*//*  Extract Row vecter from Maxtrix (Memory allocate version) *//*------------------------------------------------------------*/MATRIX      *MatExtractRow(MATRIX *m, int row){    MATRIX  *v;    int      i;    double  *ptr;    #ifdef MAT_PRI_CHK    if(row <= 0 || row > m->row){        fprintf(stderr, "Error in MatExtractRow(). Wrong row. "                        "row = %d\n", row);        exit(1);    }#endif        row--;        v = MatGen(m->col, 1);        if(v == NULL) return NULL;        for(i = 0, ptr = m->dat + m->col * row; i < m->col; i++){        v->dat[i] = ptr[i];    }        return v;}/*------------------------------------------------------------*//*  Extract Row vecter from Maxtrix  (Just point *dat ptr)    *//*------------------------------------------------------------*/MATRIX      *MatExtractRowPtr(MATRIX *m, int row){    MATRIX  *v;    int      i;    double  *ptr;    #ifdef MAT_PRI_CHK    if(row <= 0 || row > m->row){        fprintf(stderr, "Error in MatExtractRowPtr(). Wrong row. "                        "row = %d\n", row);        exit(1);    }#endif        row--;        v = MatGenInit(m->col, 1, m->dat + m->col * row);        if(m == NULL) return NULL;        return v;}/*------------------------------------------------------------*//*  Extract Column vecter from Maxtrix                        *//*------------------------------------------------------------*/MATRIX      *MatExtractCol(MATRIX *m, int col){    MATRIX  *v;    int      i;    double  *ptr;    #ifdef MAT_PRI_CHK    if(col <= 0 || col > m->col){        fprintf(stderr, "Error in MatExtractCol(). Wrong column. "                        "col = %d\n", col);        exit(1);    }#endif        col--;        v = MatGen(1, m->row);        if(v == NULL) return NULL;        for(i = 0, ptr = m->dat + col; i < m->row; i++){        v->dat[i] = *ptr;        ptr += m->col;    }        return v;}/*------------------------------------------------------------*//*  Matrix print                                              *//*------------------------------------------------------------*/MATRIX      *MatPrint(MATRIX *m, const char *format){    int     i, j;        for(i = 0; i < m->row; i++){        for(j = 0; j < m->col; j++){            printf(format, m->dat[m->col * i + j]);        }        putchar('\n');    }    putchar('\n');}/*------------------------------------------------------------*//*  Matrix print      Multi-print version                     *//*------------------------------------------------------------*/MATRIX      *MatPrintN(int num, const char *format, ... ){    va_list      list;    int          ac, i, j, r, c, ierr = FALSE;    MATRIX      *m[MAT_MAX_PRINT];        if(num > MAT_MAX_PRINT){        fprintf(stderr, "Error in MatPrintN(). "                "Number of matrix should be less equal 10. \n"                "Specified number = %d\n", num);        exit(1);            }            va_start( list, format );    for(i = 0; i < num ; i++){        m[i] = va_arg(list, MATRIX *);    }    va_end( list );        r = m[0]->row; c = m[0]->col;            for(i = 1; i < num; i++){        if(m[i]->row != r) ierr = TRUE;    }    if(ierr == TRUE){        fprintf(stderr, "Error in MatPrintN(). "                        "All matrix should have same row dimension.\n");        exit(1);            }        for(i = 0; i < r; i++){        for(ac = 0; ac < num; ac++){            for(j = 0; j < m[ac]->col; j++){                printf(format, m[ac]->dat[m[ac]->col * i + j]);            }            putchar('|');        }        putchar('\n');    }    putchar('\n');}/*------------------------------------------------------------*//*  Eliminate matrix  (Multi version)                        *//*------------------------------------------------------------*/void         MatFreeN(int num, ...){    va_list      list;    int          i;        if(num < 1){        fprintf(stderr, "Error in MatFreeN(). "                "Number of matrix to be elimanated must be greater then 0. \n"                "Specified number = %d\n", num);        exit(1);            }            va_start( list, num );    for(i = 0; i < num ; i++){        MatFree(va_arg(list, MATRIX *));    }    va_end( list );    }/*------------------------------------------------------------*//*  Transposed Matrix generation                              *//*------------------------------------------------------------*/MATRIX      *MatGenTrans(MATRIX *m){    MATRIX      *t;    int          i, j;        t = MatGen(m->row, m->col);        if( t == NULL) return NULL;        t->row = m->col; t->col = m->row;        for(i = 0; i < m->row; i++){        for(j = 0; j < m->col; j++){            t->dat[t->col*j + i] = m->dat[m->col*i + j];        }    }        return t;}/*------------------------------------------------------------*//*  Transpose Matrix ! existing matrix trnspose               *//*------------------------------------------------------------*/MATRIX      *MatTrans(MATRIX *m){    int          i, j, row, col;    double       dtmp, *ptr;    MATRIX      *t;    #ifdef MAT_PRI_CHK    if(m->flg != TRUE){        fprintf(stderr, "Error in MatTrans(). Cution! "                        "Do not apply MatTrans to fixed matrix.\n");        exit(1);    }#endif        t = MatGenTrans(m);    if( t == NULL) return NULL;        MatFree(m);    m = MatDup(t); MatFree(t);    return m;}/*------------------------------------------------------------*//*  Add with new matrix generation                            *//*------------------------------------------------------------*/MATRIX      *MatGenAdd(MATRIX *m1, MATRIX *m2){    int         i, num;    MATRIX      *res;    #ifdef MAT_PRI_CHK    if(m1->col != m2->col || m1->row != m2->row){        fprintf(stderr, "Error in MatGenAdd().  "                        "matrix dimesion should be same.\n");        exit(1);    }#endif        res = MatGen(m1->col, m1->row);        num = m1->row * m1->col;    for(i = 0; i < num; i++){        res->dat[i] = m1->dat[i] + m2->dat[i];    }        return(res);}/*------------------------------------------------------------*//*  Add with no matrix generation                            *//*------------------------------------------------------------*/MATRIX      *MatAdd(MATRIX *m1, MATRIX *m2){    int         i, num;    MATRIX      *res;    #ifdef MAT_PRI_CHK    if(m1->flg != TRUE){        fprintf(stderr, "Error in MatAdd(). Cution! "                        "Do not apply MatTrans to fixed matrix.\n");        exit(1);    }    if(m1->col != m2->col || m1->row != m2->row){        fprintf(stderr, "Error in MatAdd().  "                        "matrix dimesion should be same.");        exit(1);    }#endif        num = m1->row * m1->col;    for(i = 0; i < num; i++){        m1->dat[i] += m2->dat[i];    }        return(res);}/*------------------------------------------------------------*//*  Sub with new matrix generation                            *//*------------------------------------------------------------*/MATRIX      *MatGenSub(MATRIX *m1, MATRIX *m2){    int         i, num;    MATRIX      *res;    #ifdef MAT_PRI_CHK    if(m1->col != m2->col || m1->row != m2->row){        fprintf(stderr, "Error in MatGenSub().  "                        "matrix dimesion should be same.");        exit(1);    }#endif        res = MatGen(m1->col, m1->row);        num = m1->row * m1->col;    for(i = 0; i < num; i++){        res->dat[i] = m1->dat[i] - m2->dat[i];    }        return(res);}/*------------------------------------------------------------*//*  Sub with no matrix generation                            *//*------------------------------------------------------------*/MATRIX      *MatSub(MATRIX *m1, MATRIX *m2){    int         i, num;    MATRIX      *res;    #ifdef MAT_PRI_CHK    if(m1->flg != TRUE){        fprintf(stderr, "Error in MatSub(). Cution! "                        "Do not apply MatTrans to fixed matrix.\n");        exit(1);    }    if(m1->col != m2->col || m1->row != m2->row){        fprintf(stderr, "Error in MatSub().  "                        "matrix dimesion should be same.");        exit(1);    }#endif        num = m1->row * m1->col;    for(i = 0; i < num; i++){        m1->dat[i] -= m2->dat[i];    }        return(res);}/*------------------------------------------------------------*//*  Multiply with new matrix generation                       *//*------------------------------------------------------------*/MATRIX      *MatGenMul(MATRIX *m1, MATRIX *m2){    int          i, j, k;    MATRIX      *res;    double       dsum;    #ifdef MAT_PRI_CHK    if(m1->col != m2->row){        fprintf(stderr, "Error in MatGenMul().  "        "Couldn't calculate becouse of dimension.\n"        "1st matrix (%d x %d), 2nd matrix (%d x %d)\n",                m1->col, m1->row, m2->col, m2->row);        exit(1);    }#endif        res = MatGen(m2->col, m1->row);        res->row = m1->row;    res->col = m2->col;        for(i = 0; i < res->row; i++){        for(j = 0; j < res->col; j++){            for(k = 0, dsum = 0.0; k < m1->col; k++){                dsum += m1->dat[m1->col * i + k] * m2->dat[m2->col * k + j];            }            res->dat[res->col * i + j] = dsum;        }    }        return(res);}/*------------------------------------------------------------*//*  Invert Maxrix (Gauss Jordan)                              *//*------------------------------------------------------------*/MATRIX      *MatGenInvGJ(MATRIX *m){    int      i, j, k, n, dtype;    double   t, u, det;    MATRIX  *res;    #ifdef MAT_PRI_CHK    if(m->col != m->row){        fprintf(stderr, "Error in MatGenInvGJ().  "        "Couldn't calculate becouse of dimension.\n"        "row & column should be equal. Given dimension (%d x %d)\n",                m->col, m->row);        exit(1);    }#endif        res = MatDup(m);    if(res == NULL) return NULL;        n = m->row;    det = 1.0;    for(k = 0; k < n; k++){        t = res->dat[res->col * k + k]; det *= t;        for(i = 0; i < n; i++){            res->dat[res->col * i + k] /= t;        }        res->dat[res->col * k + k] = 1.0 / t;        for(j = 0; j < n; j++){            if(j != k){                u = res->dat[res->col * k + j];                for(i = 0; i < n; i++){                    if(i != k){                        res->dat[res->col * i + j] -=                                 res->dat[res->col * i + k] * u;                    }else{                        res->dat[res->col * i + j] = -u / t;                    }                }            }                    }            }//    fprintf(stderr, "det = %f\n", det);        dtype = isfinite(det);    if(dtype == 0){        if(MatErrStop != TRUE) return NULL;         else{            fprintf(stderr, "MatGenInvGJ() faild. Singular Martix.\n");            exit(1);        }    }    res->det = det;    return(res);}/*------------------------------------------------------------*//*   Least Squre Method (invert calc. using Gauss-Jordan)     *//*------------------------------------------------------------*/MATRIX      *MatLsmGJ(int NumVal, int NumSample, MATRIX *X, MATRIX *Y){    MATRIX      *mtmp, *XINV, *TX, *Coef, *mtmp2;        if(X->col != NumVal){        fprintf(stderr, "Error in MatLsmGJ(). Wrong dimension. \n"                "columns of X matrix & Number of variables should be same.\n"        "Specified values are: col = %d, NumVal = %d\n", X->col, NumVal);        exit(1);    }    if(X->row != NumSample){        fprintf(stderr, "Error in MatLsmGJ(). Wrong dimension. \n"                "rows of X matrix & Number of samples should be same.\n"        "Specified values are: raw = %d, NumSample = %d\n", X->row, NumSample);        exit(1);    }    if(Y->row != NumSample){        fprintf(stderr, "Error in MatLsmGJ(). Wrong dimension. \n"                "rows of Y matrix & Number of samples should be same.\n"        "Specified values are: raw = %d, NumSample = %d\n", Y->row, NumSample);        exit(1);    }    if(Y->col != 1){        fprintf(stderr, "Error in MatLsmGJ(). Wrong dimension. \n"                "column of Y matrix should be 1.\n"        "Specified value is: col = %d\n", Y->col);        exit(1);    }        TX   = MatGenTrans(X);    mtmp = MatGenMul(TX, X);    XINV = MatGenInvGJ(mtmp);         /*    mtmp2 = MatGenMul(mtmp, XINV);    MatPrint(mtmp2, "%f ");    */        MatFree(mtmp);    mtmp = MatGenMul(XINV, TX);    Coef = MatGenMul(mtmp, Y);             MatFree(mtmp); MatFree(TX); MatFree(XINV);         return Coef;}